import Austral.Memory (
    Address,
    Pointer,
    allocateBuffer,
    resizeArray,
    deallocate,
    nullCheck,
    positiveOffset,
    store,
    load
);

module body Standard.Buffer is
    pragma Unsafe_Module;

    """
    The smallest value of capacity. Enforced at array allocation
    time.
    """
    constant minimum_capacity: Index := 16;

    """
    The growth factor times the array's capacity tells us the next size of
    the array when resizing. Naively, we double the size of the array when
    hitting the capacity.
    """
    constant growth_factor: Index := 2;

    record Buffer[T: Type]: Linear is
        -- The capacity is the true underlying size. It is different from the
        -- size since we allocate more space than we need in order to minimize
        -- frequent reallocation.
        capacity: Index;
        -- The number of elements actually stored in the array.
        size: Index;
        -- The underlying heap array.
        array: Pointer[T];
    end;

    """
    Check invariants.
    """
    generic [T: Type, R: Region]
    function invariants(buf: &[Buffer[T], R]): Unit is
        -- Size is always strictly less than the capacity. When resizing, if
        -- the size matches the capacity, we bump up.
        if buf-> size >= buf->capacity then
            abort("Buffer size >= capacity");
        end;
        -- Capacity is always non-zero.
        if buf->capacity = 0 then
            abort("Buffer capacity = 0");
        end;
        return nil;
    end;

    generic [T: Type]
    function allocateEmpty(): Buffer[T] is
        let opt: Option[Buffer[T]] := safeAllocateEmpty();
        case opt of
            when Some(value: Buffer[T]) do
                return value;
            when None do
                abort("allocateEmpty: allocation failed");
        end case;
    end;

    generic [T: Type]
    function safeAllocateEmpty(): Option[Buffer[T]] is
        let addr: Address[T] := allocateBuffer(minimum_capacity);
        case nullCheck(addr) of
            when Some(value: Pointer[T]) do
                let buf: Buffer[T] := Buffer(
                    capacity => minimum_capacity,
                    size => 0,
                    data => value,
                );
                return Some(buf);
            when None do
                return None();
        end case;
    end;

    generic [T: Free]
    function initialize(size: Index, initialElement: T): Buffer[T] is
        let opt: Option[Buffer[T]] := safeInitialize(size, initialElement);
        case opt of
            when Some(value: Buffer[T]) do
                return value;
            when None do
                abort("initialize: allocation failed");
        end case;
    end;

    generic [T: Free]
    function safeInitialize(size: Index, initialElement: T): Option[Buffer[T]] is
        let capacity: Index := max(size, minimum_capacity);
        let addr: Address[T] := allocateBuffer(capacity);
        case nullCheck(addr) of
            when Some(value: Pointer[T]) do
                let buf: Buffer[T] := Buffer(
                    capacity => capacity,
                    size => size,
                    data => value,
                );
                fill(&!buf, initialElement);
                return Some(buf);
            when None do
                return None();
        end case;
    end;
end module body.