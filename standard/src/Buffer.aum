import Austral.Memory (
    Address,
    Pointer,
    allocateBuffer,
    resizeArray,
    deallocate,
    nullCheck,
    positiveOffset,
    store,
    load
);

module body Standard.Buffer is
    pragma Unsafe_Module;

    """
    The smallest value of capacity. Enforced at array allocation
    time.
    """
    constant minimum_capacity: Index := 16;

    """
    The growth factor times the array's capacity tells us the next size of
    the array when resizing. Naively, we double the size of the array when
    hitting the capacity.
    """
    constant growth_factor: Index := 2;

    record Buffer[T: Type]: Linear is
        -- The capacity is the true underlying size. It is different from the
        -- size since we allocate more space than we need in order to minimize
        -- frequent reallocation.
        capacity: Index;
        -- The number of elements actually stored in the array.
        size: Index;
        -- The underlying heap array.
        array: Pointer[T];
    end;

    """
    Check invariants.
    """
    generic [T: Type, R: Region]
    function invariants(buf: &[Buffer[T], R]): Unit is
        -- Size is always strictly less than the capacity. When resizing, if
        -- the size matches the capacity, we bump up.
        if buf-> size >= buf->capacity then
            abort("Buffer size >= capacity");
        end if;
        -- Capacity is always non-zero.
        if buf->capacity = 0 then
            abort("Buffer capacity = 0");
        end if;
        return nil;
    end;

    ---
    --- Lifecycle
    ---

    generic [T: Type]
    function allocateEmpty(): Buffer[T] is
        let opt: Option[Buffer[T]] := safeAllocateEmpty();
        case opt of
            when Some(value: Buffer[T]) do
                return value;
            when None do
                abort("allocateEmpty: allocation failed");
        end case;
    end;

    generic [T: Type]
    function safeAllocateEmpty(): Option[Buffer[T]] is
        let addr: Address[T] := allocateBuffer(minimum_capacity);
        case nullCheck(addr) of
            when Some(value: Pointer[T]) do
                let buf: Buffer[T] := Buffer(
                    capacity => minimum_capacity,
                    size => 0,
                    array => value
                );
                return Some(value => buf);
            when None do
                return None();
        end case;
    end;

    generic [T: Free]
    function initialize(size: Index, initialElement: T): Buffer[T] is
        let opt: Option[Buffer[T]] := safeInitialize(size, initialElement);
        case opt of
            when Some(value: Buffer[T]) do
                return value;
            when None do
                abort("initialize: allocation failed");
        end case;
    end;

    generic [T: Free]
    function safeInitialize(size: Index, initialElement: T): Option[Buffer[T]] is
        let capacity: Index := max(size, minimum_capacity);
        let addr: Address[T] := allocateBuffer(capacity);
        case nullCheck(addr) of
            when Some(value: Pointer[T]) do
                let buf: Buffer[T] := Buffer(
                    capacity => capacity,
                    size => size,
                    array => value
                );
                fill(&!buf, initialElement);
                return Some(value => buf);
            when None do
                return None();
        end case;
    end;

    -- TODO: move this to a better place
    function max(a: Index, b: Index): Index is
        if a > b then
            return a;
        else
            return b;
        end if;
    end;

    generic [T: Free]
    function destroyFree(buffer: Buffer[T]): Unit is
        let { capacity: Index, size: Index, array: Pointer[T] } := buffer;
        deallocate(array);
        return nil;
    end;

    generic [T: Type]
    function destroyEmpty(buffer: Buffer[T]): Unit is
        let { capacity: Index, size: Index, array: Pointer[T] } := buffer;
        if size /= 0 then
            abort("destroyEmpty called with a non-empty buffer.");
        end if;
        deallocate(array);
        return nil;
    end;

    ---
    --- Retrieve
    ---

    """
    Return the length of the buffer.
    """
    generic [T: Type, R: Region]
    function length(buf: &[Buffer[T], R]): Index is
        return !buf->size;
    end;


    generic [T: Free, R: Region]
    function nth(buf: &![Buffer[T], R], pos: Index): T is
        if pos >= (!buf->size) then
            abort("nth: index out of range");
        end if;
        let ptr: Pointer[T] := positiveOffset(!buf->array, pos);
        let elem: T := load(ptr);
        return elem;
    end;

    ---
    --- Update
    ---

    """
    Store `element` in the given position of `buf`.
    """
    generic [T: Free, R: Region]
    function storeNth(buf: &![Buffer[T], R], pos: Index, element: T): Unit is
        if pos >= (!buf->size) then
            abort("storeNth: index out of range");
        end if;
        let ptr: Pointer[T] := positiveOffset(!buf->array, pos);
        store(ptr, element);
        return nil;
    end;


    generic [T: Type, R: Region]
    function swapNth(buf: &![Buffer[T], R], pos: Index, element: T): T is
        if pos >= (!buf->size) then
            abort("swapNth: index out of range");
        end if;
        let ptr: Pointer[T] := positiveOffset(!buf->array, pos);
        let previous: T := load(ptr);
        store(ptr, element);
        return previous;
    end;

    generic [T: Free, R: Region]
    function fill(buf: &![Buffer[T], R], element: T): Unit is
        for i from 0 to (!buf->size) - 1 do
            storeNth(buf, element);
        end for;
        return nil;
    end;
end module body.